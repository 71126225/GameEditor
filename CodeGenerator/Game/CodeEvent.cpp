#include "CodeEvent.h"

void CodeEvent::generate()
{
	if (cppGamePath.length() == 0)
	{
		return;
	}

	string cppHeaderPath = cppGamePath + "EventSystem/";
	string cppEventFilePath = cppHeaderPath + "Event/";

	string cmdFile;
	openTxtFile("Event.txt", cmdFile);
	if (cmdFile.length() == 0)
	{
		ERROR("未找文件Event.txt");
		return;
	}
	myVector<string> eventLineList;
	split(cmdFile.c_str(), "\r\n", eventLineList);
	myVector<pair<string, string>> eventList;
	FOR_VECTOR(eventLineList)
	{
		myVector<string> splitResult;
		split(eventLineList[i].c_str(), "\t", splitResult);
		if (splitResult.size() != 2)
		{
			ERROR("事件文件解析错误:" + eventLineList[i]);
		}
		eventList.push_back(make_pair(splitResult[0], splitResult[1]));
	}
	END(eventLineList);
	// 生成StringDefineEvent文件
	generateStringDefineEvent(eventList, cppStringDefinePath);
	// 生成EventHeader.h文件
	generateHeaderFile(eventList, cppHeaderPath);
	// 生成EventType.h文件
	generateEventType(eventList, cppHeaderPath);
	FOR_VECTOR(eventList)
	{
		generateEventFile(eventList[i].first, cppEventFilePath);
	}
	END(eventList);
}

// EventHeader.h文件
void CodeEvent::generateHeaderFile(const myVector<pair<string, string>>& eventList, string headerPath)
{
	string str0;
	line(str0, "#ifndef _EVENT_HEADER_H_");
	line(str0, "#define _EVENT_HEADER_H_");
	line(str0, "");
	uint count = eventList.size();
	FOR_I(count)
	{
		line(str0, "#include \"" + eventList[i].first + ".h\"");
	}
	line(str0, "");
	line(str0, "#endif", false);

	str0 = ANSIToUTF8(str0.c_str(), true);
	writeFile(headerPath + "EventHeader.h", str0);
}

// StringDefineEvent.h和StringDefineEvent.cpp
void CodeEvent::generateStringDefineEvent(const myVector<pair<string, string>>& eventList, string stringDefinePath)
{
	// 头文件
	string header;
	line(header, "#ifdef _STRING_DEFINE_EVENT_H_");
	line(header, "#error \"特殊头文件,只能被StringDefine.h所包含\"");
	line(header, "#else");
	line(header, "#define _STRING_DEFINE_EVENT_H_");
	line(header, "");
	uint cmdCount = eventList.size();
	FOR_I(cmdCount)
	{
		line(header, stringDeclare(eventList[i].first));
	}
	line(header, "");
	line(header, "#endif");
	writeFile(stringDefinePath + "StringDefineEvent.h", ANSIToUTF8(header.c_str(), true));

	// 源文件
	string source;
	line(source, "#include \"GameHeader.h\"");
	writeFile(stringDefinePath + "StringDefineEvent.cpp", ANSIToUTF8(source.c_str(), true));
}

// EventType.h
void CodeEvent::generateEventType(const myVector<pair<string, string>>& eventList, string headerPath)
{
	string str0;
	line(str0, "#ifndef _EVENT_TYPE_H_");
	line(str0, "#define _EVENT_TYPE_H_");
	line(str0, "");
	line(str0, "// 游戏事件定义");
	line(str0, "class EVENT_TYPE");
	line(str0, "{");
	line(str0, "public:");
	// 由于需要添加默认的无效值,所以复制一份列表
	myVector<pair<string, string>> newList;
	newList.push_back(make_pair("None", "// 无效值"));
	newList.merge(eventList);
	FOR_VECTOR_CONST(newList)
	{
		string type = removeStartString(nameToUpper(newList[i].first), "_EVENT_");
		// 由于None转换出来是以_开头,所以还是需要确保是字母开头
		type = removeStartString(type, "_");
		string str = "\tconst static ushort " + type + " = " + intToString(i) + ";";
		uint tableCount = generateAlignTableCount(str, 48);
		FOR_J(tableCount)
		{
			str += "\t";
		}
		line(str0, str + newList[i].second);
	}
	line(str0, "};");
	line(str0, "");
	line(str0, "#endif", false);

	writeFile(headerPath + "EventType.h", ANSIToUTF8(str0.c_str(), true));
}

void CodeEvent::generateEventFile(const string& eventName, string eventPath)
{
	string headerFullPath = eventPath + eventName + ".h";
	if (isFileExist(headerFullPath))
	{
		return;
	}
	string header;
	string marcoName = nameToUpper(eventName) + "_H_";
	string typeStr = nameToUpper(eventName.substr(strlen("Event")), false);
	line(header, "#ifndef " + marcoName);
	line(header, "#define " + marcoName);
	line(header, "");
	line(header, "#include \"GameEvent.h\"");
	line(header, "");
	line(header, "class " + eventName + " : public GameEvent");
	line(header, "{");
	line(header, "public:");
	line(header, "\t" + eventName + "()");
	line(header, "\t{");
	line(header, "\t\tmType = EVENT_TYPE::" + typeStr + ";");
	line(header, "\t}");
	line(header, "public:");
	line(header, "};");
	line(header, "");
	line(header, "#endif", false);

	writeFile(headerFullPath, ANSIToUTF8(header.c_str(), true));
}